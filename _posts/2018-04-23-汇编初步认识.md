---
layout: post
title:  "汇编初步认识"
date:   2018-04-23 13:52:00 +0800
description: '汇编知识'
tag: iOS逆向
---

## 汇编语言的特点
- 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
- 能够不受编译器的限制，对生成的二进制代码进行完全的控制
- 目标代码简短，占用内存少，执行速度快
- 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性
- 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护
- 不区分大小写，比如mov和MOV是一样的

## 汇编能干嘛
- 编写驱动程序、操作系统（比如Linux内核的某些关键部分）
对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）
- 软件安全
    - 病毒分析与防治
    - 逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客
- 理解整个计算机系统的最佳起点和最有效途径
- 为编写高效代码打下基础
- 弄清代码的本质
    - 函数的本质究竟是什么?
    - ++a + ++a + ++a 底层如何执行的?
    - 编译器到底帮我们干了什么?
    - DEBUG模式和RELEASE模式有什么关键的地方被我们忽略
    - ......

## 汇编语言的种类

* 当下主流的汇编语言
    * 8086汇编（8086处理器是16bit的CPU）
    * Win32汇编
    * Win64汇编
    * ARM汇编（嵌入式、Mac、iOS）
    * ......
* iOS使用的是ARM汇编, 不同的设备之间也有差异, 因为CPU的架构不同

|架构	| 设备 |
| --- | --- |
| armv6 | iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch |
| armv7 | iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4|
|armv7s | iPhone5, iPhone5C, iPad4(iPad with Retina Display) |
| arm64 | iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后 |

## 总线的分类

* 地址总线
* 数据总线
* 控制总线

1. 地址总线的宽度决定了CPU的寻址能力, 比如, 8086的地址总线宽度是20, 所以他的寻址能力就是1M(2^20)
2. 数据总线的宽度决定了CPU单次传输数据的zon总量, 也就是数据传输速度, 比如8086的数据总线宽度是16, 那么它单次最多传输2个字节
3. 控制总线的宽度决定了CPU对其他器件的控制能力

## 寄存器
* 对我们来说, CPU中最重要的是部件是寄存器, 我们可以通过修改寄存器中的值, 来显现对CPU的控制
* 不同的CPU, 寄存器的个数和结构是不同的

## 通用寄存器

* ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）
    * 那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.
    * 比如 w0 就是 x0的低32位!
* 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算

## pc寄存器(program counter)
* 为指令指针寄存器，它指示了CPU当前要读取指令的地址
* 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
* CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
    * 比如 1110 0000 0000 0011 0000 1000 1010 1010
    * 可以当做数据 0xE003008AA
    * 也可以当做指令 mov x0, x8
* CPU根据什么将内存中的信息看做指令？
    * CPU将pc指向的内存单元的内容看做指令
    * 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过
    
## bl指令
* CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令
* ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如
    * mov x0,#10、mov x1,#20
* 但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能
* ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令

## SP和FP寄存器
* sp寄存器在任意时刻会保存我们栈顶的地址.
* fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址!()

> 注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\ldp str\stp
ARM64里面 对栈的操作是16字节对齐的!!

## 关于内存读写指令

> 注意:读/写 数据是都是往高地址读/写

1. **str(store register)指令**
将数据从寄存器中读出来,存到内存中
2. **ldr(load register)指令**
将数据从内存中读出来,存到寄存器中
3. 此ldr 和 str 的变种ldp 和 stp 还可以操作2个寄存器.

## bl和ret指令
####bl标号

* 将下一条指令的地址放入lr(x30)寄存器
* 转到标号处执行指令

#### ret

* 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!

>ARM64平台的特色指令,它面向硬件做了优化处理的

#### x30寄存器
x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值!

>注意:在函数嵌套调用的时候.需要讲x30入栈!



